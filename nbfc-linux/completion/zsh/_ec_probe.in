#compdef ec_probe

# This script was generated by crazy-complete.
# crazy-complete: A tool that creates robust and reliable autocompletion scripts for Bash, Fish and Zsh.
# For more information, visit: https://github.com/crazy-complete/crazy-complete

_ec_probe_zsh_query() {
  # ===========================================================================
  #
  # This function is for querying the command line.
  #
  # COMMANDS
  #   init <OPTIONS> <ARGS...>
  #     This is the first call you have to make, otherwise the other commands
  #     won't (successfully) work.
  #
  #     It parses <ARGS> according to <OPTIONS> and stores results in the
  #     variables POSITIONALS, HAVING_OPTIONS and OPTION_VALUES.
  #
  #     The first argument is a comma-separated list of options that the parser
  #     should know about. Short options (-o), long options (--option), and
  #     old-style options (-option) are supported.
  #
  #     If an option takes an argument, it is suffixed by '='.
  #     If an option takes an optional argument, it is suffixed by '=?'.
  #
  #   get_positional <NUM>
  #     Prints out the positional argument number NUM (starting from 1)
  #
  #   has_option [WITH_INCOMPLETE] <OPTIONS...>
  #     Checks if an option given in OPTIONS is passed on commandline.
  #     If an option requires an argument, this command returns true only if the
  #     option includes an argument. If 'WITH_INCOMPLETE' is specified, it also
  #     returns true for options missing their arguments.
  #
  #   option_is <OPTIONS...> -- <VALUES...>
  #     Checks if one option in OPTIONS has a value of VALUES.
  #
  # EXAMPLE
  #   local POSITIONALS HAVING_OPTIONS OPTION_VALUES
  #   zsh_query init '-f,-a=,-optional=?' program_name -f -optional -a foo bar
  #   zsh_query has_option -f
  #   zsh_query option_is -a -- foo
  #
  #   Here, -f is a flag, -a takes an argument, and -optional takes an optional
  #   argument.
  #
  #   Both queries return true.
  #
  # ===========================================================================

  __zsh_query_contains() {
    local arg='' key="$1"; shift
    for arg; do [[ "$key" == "$arg" ]] && return 0; done
    return 1
  }

  if [[ $# == 0 ]]; then
    echo "_ec_probe_zsh_query: missing command" >&2
    return 1;
  fi

  local cmd="$1"
  shift

  case "$cmd" in
    get_positional)
      if test $# -ne 1; then
        echo "_ec_probe_zsh_query: get_positional: takes exactly one argument" >&2
        return 1;
      fi

      if test "$1" -eq 0; then
        echo "_ec_probe_zsh_query: get_positional: positionals start at 1, not 0!" >&2
        return 1
      fi

      printf "%s" "${POSITIONALS[$1]}"
      return 0
      ;;
    has_option)
      if test $# -eq 0; then
        echo "_ec_probe_zsh_query: has_option: arguments required" >&2
        return 1;
      fi

      local option=''
      for option in "${HAVING_OPTIONS[@]}"; do
        __zsh_query_contains "$option" "$@" && return 0
      done

      return 1
      ;;
    option_is)
      local -a cmd_option_is_options cmd_option_is_values
      local end_of_options_num=0

      while test $# -ge 1; do
        if [[ "$1" == "--" ]]; then
          (( ++end_of_options_num ))
        elif test $end_of_options_num -eq 0; then
          cmd_option_is_options+=("$1")
        elif test $end_of_options_num -eq 1; then
          cmd_option_is_values+=("$1")
        fi

        shift
      done

      if test ${#cmd_option_is_options[@]} -eq 0; then
        echo "_ec_probe_zsh_query: option_is: missing options" >&2
        return 1
      fi

      if test ${#cmd_option_is_values[@]} -eq 0; then
        echo "_ec_probe_zsh_query: option_is: missing values" >&2
        return 1
      fi

      local I=${#HAVING_OPTIONS[@]}
      while test $I -ge 1; do
        local option="${HAVING_OPTIONS[$I]}"
        if __zsh_query_contains "$option" "${cmd_option_is_options[@]}"; then
          local VALUE="${OPTION_VALUES[$I]}"
          __zsh_query_contains "$VALUE" "${cmd_option_is_values[@]}" && return 0
        fi

        (( --I ))
      done

      return 1
      ;;
    init)
      local IFS=','
      local -a options=(${=1})
      unset IFS
      shift
      ;;
    *)
      echo "_ec_probe_zsh_query: argv[1]: invalid command" >&2
      return 1
      ;;
  esac

  # continuing init...

  # ===========================================================================
  # Parsing of available options
  # ===========================================================================

  local -a  long_opts_with_arg=()  long_opts_with_optional_arg=()  long_opts_without_arg=()
  local -a short_opts_with_arg=() short_opts_with_optional_arg=() short_opts_without_arg=()

  local option=''
  for option in "${options[@]}"; do
    case "$option" in
      --?*=)    long_opts_with_arg+=("${option%=}");;
      --?*=\?)  long_opts_with_optional_arg+=("${option%=?}");;
      --?*)     long_opts_without_arg+=("$option");;
      -?=)      short_opts_with_arg+=("${option%=}");;
      -?=\?)    short_opts_with_optional_arg+=("${option%=?}");;
      -?)       short_opts_without_arg+=("$option");;
      *) echo "_ec_probe_zsh_query: $option: not a valid short, long or oldstyle option" >&2; return 1;;
    esac
  done

  # ===========================================================================
  # Parsing of command line options
  # ===========================================================================

  POSITIONALS=()
  HAVING_OPTIONS=()
  OPTION_VALUES=()
  INCOMPLETE_OPTION=''

  local argi=2 # argi[1] is program name
  while [[ $argi -le $# ]]; do
    local arg="${@[$argi]}"
    local have_trailing_arg=$(test $argi -lt $# && echo true || echo false)

    case "$arg" in
      -)
        POSITIONALS+=(-);;
      --)
        for argi in $(seq $((argi + 1)) $#); do
          POSITIONALS+=("${@[$argi]}")
        done
        break;;
      --*=*)
        HAVING_OPTIONS+=("${arg%%=*}")
        OPTION_VALUES+=("${arg#*=}");;
      --*)
        if __zsh_query_contains "$arg" "${long_opts_with_arg[@]}"; then
          if $have_trailing_arg; then
            HAVING_OPTIONS+=("$arg")
            OPTION_VALUES+=("${@[$((argi + 1))]}")
            (( argi++ ))
          fi
        else
          HAVING_OPTIONS+=("$arg")
          OPTION_VALUES+=("")
        fi
        ;;
      -*)
        local end_of_parsing=false

        local arg_length=${#arg}
        local i=1
        while ! $end_of_parsing && test $i -lt $arg_length; do
          local option="-${arg:$i:1}"
          local trailing_chars="${arg:$((i+1))}"

          if __zsh_query_contains "$option" "${short_opts_without_arg[@]}"; then
            HAVING_OPTIONS+=("$option")
            OPTION_VALUES+=("")
          elif __zsh_query_contains "$option" "${short_opts_with_arg[@]}"; then
            end_of_parsing=true

            if [[ -n "$trailing_chars" ]]; then
              HAVING_OPTIONS+=("$option")
              OPTION_VALUES+=("$trailing_chars")
            elif $have_trailing_arg; then
              HAVING_OPTIONS+=("$option")
              OPTION_VALUES+=("${@[$((argi + 1))]}")
              (( argi++ ))
            fi
          elif __zsh_query_contains "$option" "${short_opts_with_optional_arg[@]}"; then
            end_of_parsing=true
            HAVING_OPTIONS+=("$option")
            OPTION_VALUES+=("$trailing_chars") # may be empty
          fi

          (( i++ ))
        done
        ;;
      *)
        POSITIONALS+=("$arg");;
    esac

    (( argi++ ))
  done
}

_ec_probe__command() {
  local -a items=(
    dump:'Dump all EC registers'
    load:'Load a previously made dump into the embedded controller'
    read:'Read a byte from a EC register'
    write:'Write a byte to a EC register'
    monitor:'Monitor all EC registers for changes'
    watch:'Monitor all EC registers for changes (alternative version)'
    acpi_call:'Call an ACPI method'
    shell:'Read commands from STDIN'
  )

  _describe -- command items
}

_ec_probe() {
  local opts=-h,--help,-e=,--embedded-controller=
  local HAVING_OPTIONS=() OPTION_VALUES=() POSITIONALS=() INCOMPLETE_OPTION=''
  _ec_probe_zsh_query init "$opts" "${words[@]}"

  case "$(_ec_probe_zsh_query get_positional 1)" in
    (dump) _ec_probe_dump; return $?;;
    (load) _ec_probe_load; return $?;;
    (read) _ec_probe_read; return $?;;
    (write) _ec_probe_write; return $?;;
    (monitor) _ec_probe_monitor; return $?;;
    (watch) _ec_probe_watch; return $?;;
    (acpi_call) _ec_probe_acpi_call; return $?;;
    (shell) _ec_probe_shell; return $?;;
  esac

  local -a args=(
    '(--help -h)'{-h,--help}'[show this help message and exit]'
    '(--embedded-controller -e)'{-e+,--embedded-controller=}'[Specify embedded controller to use]':EC:'(acpi_ec ec_sys dev_port)'
    1:command1:_ec_probe__command
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_dump() {
  local -a args=(
    '(--color -c)'{-c,--color}'[Force colored output]'
    '(--no-color -C)'{-C,--no-color}'[Disable colored output]'
    1:command1:_ec_probe__command
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_load() {
  local -a args=(
    1:command1:_ec_probe__command
    2:FILE:_files
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_read() {
  local -a args=(
    '(--word -w)'{-w,--word}'[Combine two registers into one]'
    1:command1:_ec_probe__command
    2:'Register source':'({0..255})'
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_write() {
  local -a args=(
    '(--word -w)'{-w,--word}'[Combine two registers into one]'
    1:command1:_ec_probe__command
    2:'Register destination':'({0..255})'
    3:'Value to write':_numbers
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_monitor() {
  local -a args=(
    '(--interval -i)'{-i+,--interval=}'[Monitored timespan]':seconds:"_numbers -f"
    '(--timespan -t)'{-t+,--timespan=}'[Set poll intervall]':seconds:_numbers
    '(--report -r)'{-r+,--report=}'[Save all readings as a CSV file]':report:_files
    '(--clearly -c)'{-c,--clearly}'[Blanks out consecutive duplicate readings]'
    '(--decimal -d)'{-d,--decimal}'[Output readings in decimal format instead of hexadecimal format]'
    1:command1:_ec_probe__command
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_watch() {
  local -a args=(
    '(--interval -i)'{-i+,--interval=}'[Sets the update interval in seconds]':seconds:"_numbers -f"
    '(--timespan -t)'{-t+,--timespan=}'[Sets how many seconds the program will run]':seconds:_numbers
    1:command1:_ec_probe__command
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_acpi_call() {
  local -a args=(
    1:command1:_ec_probe__command
    2:'Method to call':' '
    3:'First argument':_numbers
    4:'Second argument':_numbers
    5:'Third argument':_numbers
    6:'Fourth argument':_numbers
    7:'Fifth argument':_numbers
    8:'Sixth argument':_numbers
    9:'Seventh argument':_numbers
    10:'Eighth argument':_numbers
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe_shell() {
  local -a args=(
    1:command1:_ec_probe__command
  )
  _arguments -S -s -w "${args[@]}"
}

_ec_probe "$@"

# vim: ft=zsh ts=2 sts=2 sw=2 et
