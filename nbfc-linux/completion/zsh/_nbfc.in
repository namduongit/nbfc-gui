#compdef nbfc

# This script was generated by crazy-complete.
# crazy-complete: A tool that creates robust and reliable autocompletion scripts for Bash, Fish and Zsh.
# For more information, visit: https://github.com/crazy-complete/crazy-complete

_nbfc_zsh_query() {
  # ===========================================================================
  #
  # This function is for querying the command line.
  #
  # COMMANDS
  #   init <OPTIONS> <ARGS...>
  #     This is the first call you have to make, otherwise the other commands
  #     won't (successfully) work.
  #
  #     It parses <ARGS> according to <OPTIONS> and stores results in the
  #     variables POSITIONALS, HAVING_OPTIONS and OPTION_VALUES.
  #
  #     The first argument is a comma-separated list of options that the parser
  #     should know about. Short options (-o), long options (--option), and
  #     old-style options (-option) are supported.
  #
  #     If an option takes an argument, it is suffixed by '='.
  #     If an option takes an optional argument, it is suffixed by '=?'.
  #
  #   get_positional <NUM>
  #     Prints out the positional argument number NUM (starting from 1)
  #
  #   has_option [WITH_INCOMPLETE] <OPTIONS...>
  #     Checks if an option given in OPTIONS is passed on commandline.
  #     If an option requires an argument, this command returns true only if the
  #     option includes an argument. If 'WITH_INCOMPLETE' is specified, it also
  #     returns true for options missing their arguments.
  #
  #   option_is <OPTIONS...> -- <VALUES...>
  #     Checks if one option in OPTIONS has a value of VALUES.
  #
  # EXAMPLE
  #   local POSITIONALS HAVING_OPTIONS OPTION_VALUES
  #   zsh_query init '-f,-a=,-optional=?' program_name -f -optional -a foo bar
  #   zsh_query has_option -f
  #   zsh_query option_is -a -- foo
  #
  #   Here, -f is a flag, -a takes an argument, and -optional takes an optional
  #   argument.
  #
  #   Both queries return true.
  #
  # ===========================================================================

  __zsh_query_contains() {
    local arg='' key="$1"; shift
    for arg; do [[ "$key" == "$arg" ]] && return 0; done
    return 1
  }

  if [[ $# == 0 ]]; then
    echo "_nbfc_zsh_query: missing command" >&2
    return 1;
  fi

  local cmd="$1"
  shift

  case "$cmd" in
    get_positional)
      if test $# -ne 1; then
        echo "_nbfc_zsh_query: get_positional: takes exactly one argument" >&2
        return 1;
      fi

      if test "$1" -eq 0; then
        echo "_nbfc_zsh_query: get_positional: positionals start at 1, not 0!" >&2
        return 1
      fi

      printf "%s" "${POSITIONALS[$1]}"
      return 0
      ;;
    has_option)
      if test $# -eq 0; then
        echo "_nbfc_zsh_query: has_option: arguments required" >&2
        return 1;
      fi

      local option=''
      for option in "${HAVING_OPTIONS[@]}"; do
        __zsh_query_contains "$option" "$@" && return 0
      done

      return 1
      ;;
    option_is)
      local -a cmd_option_is_options cmd_option_is_values
      local end_of_options_num=0

      while test $# -ge 1; do
        if [[ "$1" == "--" ]]; then
          (( ++end_of_options_num ))
        elif test $end_of_options_num -eq 0; then
          cmd_option_is_options+=("$1")
        elif test $end_of_options_num -eq 1; then
          cmd_option_is_values+=("$1")
        fi

        shift
      done

      if test ${#cmd_option_is_options[@]} -eq 0; then
        echo "_nbfc_zsh_query: option_is: missing options" >&2
        return 1
      fi

      if test ${#cmd_option_is_values[@]} -eq 0; then
        echo "_nbfc_zsh_query: option_is: missing values" >&2
        return 1
      fi

      local I=${#HAVING_OPTIONS[@]}
      while test $I -ge 1; do
        local option="${HAVING_OPTIONS[$I]}"
        if __zsh_query_contains "$option" "${cmd_option_is_options[@]}"; then
          local VALUE="${OPTION_VALUES[$I]}"
          __zsh_query_contains "$VALUE" "${cmd_option_is_values[@]}" && return 0
        fi

        (( --I ))
      done

      return 1
      ;;
    init)
      local IFS=','
      local -a options=(${=1})
      unset IFS
      shift
      ;;
    *)
      echo "_nbfc_zsh_query: argv[1]: invalid command" >&2
      return 1
      ;;
  esac

  # continuing init...

  # ===========================================================================
  # Parsing of available options
  # ===========================================================================

  local -a  long_opts_with_arg=()  long_opts_with_optional_arg=()  long_opts_without_arg=()
  local -a short_opts_with_arg=() short_opts_with_optional_arg=() short_opts_without_arg=()

  local option=''
  for option in "${options[@]}"; do
    case "$option" in
      --?*=)    long_opts_with_arg+=("${option%=}");;
      --?*=\?)  long_opts_with_optional_arg+=("${option%=?}");;
      --?*)     long_opts_without_arg+=("$option");;
      -?=)      short_opts_with_arg+=("${option%=}");;
      -?=\?)    short_opts_with_optional_arg+=("${option%=?}");;
      -?)       short_opts_without_arg+=("$option");;
      *) echo "_nbfc_zsh_query: $option: not a valid short, long or oldstyle option" >&2; return 1;;
    esac
  done

  # ===========================================================================
  # Parsing of command line options
  # ===========================================================================

  POSITIONALS=()
  HAVING_OPTIONS=()
  OPTION_VALUES=()
  INCOMPLETE_OPTION=''

  local argi=2 # argi[1] is program name
  while [[ $argi -le $# ]]; do
    local arg="${@[$argi]}"
    local have_trailing_arg=$(test $argi -lt $# && echo true || echo false)

    case "$arg" in
      -)
        POSITIONALS+=(-);;
      --)
        for argi in $(seq $((argi + 1)) $#); do
          POSITIONALS+=("${@[$argi]}")
        done
        break;;
      --*=*)
        HAVING_OPTIONS+=("${arg%%=*}")
        OPTION_VALUES+=("${arg#*=}");;
      --*)
        if __zsh_query_contains "$arg" "${long_opts_with_arg[@]}"; then
          if $have_trailing_arg; then
            HAVING_OPTIONS+=("$arg")
            OPTION_VALUES+=("${@[$((argi + 1))]}")
            (( argi++ ))
          fi
        else
          HAVING_OPTIONS+=("$arg")
          OPTION_VALUES+=("")
        fi
        ;;
      -*)
        local end_of_parsing=false

        local arg_length=${#arg}
        local i=1
        while ! $end_of_parsing && test $i -lt $arg_length; do
          local option="-${arg:$i:1}"
          local trailing_chars="${arg:$((i+1))}"

          if __zsh_query_contains "$option" "${short_opts_without_arg[@]}"; then
            HAVING_OPTIONS+=("$option")
            OPTION_VALUES+=("")
          elif __zsh_query_contains "$option" "${short_opts_with_arg[@]}"; then
            end_of_parsing=true

            if [[ -n "$trailing_chars" ]]; then
              HAVING_OPTIONS+=("$option")
              OPTION_VALUES+=("$trailing_chars")
            elif $have_trailing_arg; then
              HAVING_OPTIONS+=("$option")
              OPTION_VALUES+=("${@[$((argi + 1))]}")
              (( argi++ ))
            fi
          elif __zsh_query_contains "$option" "${short_opts_with_optional_arg[@]}"; then
            end_of_parsing=true
            HAVING_OPTIONS+=("$option")
            OPTION_VALUES+=("$trailing_chars") # may be empty
          fi

          (( i++ ))
        done
        ;;
      *)
        POSITIONALS+=("$arg");;
    esac

    (( argi++ ))
  done
}

_nbfc__command() {
  local -a items=(
    start:'Start the service'
    stop:'Stop the service'
    restart:'Restart the service'
    status:'Show the service status'
    config:'List or apply configs'
    set:'Control fan speed'
    sensors:'Configure fan sensors'
    update:'Download new configuration files'
    wait-for-hwmon:'Wait for /sys/class/hwmon/hwmon* files'
    get-model-name:'Print model name for notebook'
    warranty:'Show warranty'
    donate:'Show how to support the project'
    help:'Show help'
  )

  _describe -- command items
}

_nbfc_exec() {
  local -a describe=()
  local item='' desc=''

  while IFS=$'\t' read -r item desc; do
    item="${item//:/\\:}"
    describe+=("$item:$desc")
  done < <(eval "$1")

  _describe '' describe
}

_nbfc_sensors_command() {
  local -a items=(
    list:'List available sensors and temperature files'
    show:'Show all available fans with their configuration'
    set:'Configure sensors and algorithm type for a fan'
  )

  _describe -- command items
}

_nbfc() {
  local opts=-h,--help,--version
  local HAVING_OPTIONS=() OPTION_VALUES=() POSITIONALS=() INCOMPLETE_OPTION=''
  _nbfc_zsh_query init "$opts" "${words[@]}"

  case "$(_nbfc_zsh_query get_positional 1)" in
    (start) _nbfc_start; return $?;;
    (stop) _nbfc_stop; return $?;;
    (restart) _nbfc_restart; return $?;;
    (status) _nbfc_status; return $?;;
    (config) _nbfc_config; return $?;;
    (set) _nbfc_set; return $?;;
    (sensors) _nbfc_sensors; return $?;;
    (update) _nbfc_update; return $?;;
    (wait-for-hwmon) _nbfc_wait_for_hwmon; return $?;;
    (get-model-name) _nbfc_get_model_name; return $?;;
    (warranty) _nbfc_warranty; return $?;;
    (donate) _nbfc_donate; return $?;;
    (help) _nbfc_help; return $?;;
  esac

  local -a args=(
    '(--help -h)'{-h,--help}'[show this help message and exit]'
    '(--version)'--version"[show program's version number and exit]"
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_start() {
  local -a args=(
    '(--read-only -r)'{-r,--read-only}'[Start in read-only mode]'
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_stop() {
  local -a args=(
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_restart() {
  local -a args=(
    '(--read-only -r)'{-r,--read-only}'[Restart in read-only mode]'
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_status() {
  local -a args=(
    '(--fan --service -f -s --all -a)'{-a,--all}'[Show service and fan status (default)]'
    '(--all --fan -a -f --service -s)'{-s,--service}'[Show service status]'
    '(--all --service -a -s --fan -f)'{-f+,--fan=}'[Show status of fan (zero based)]':'FAN INDEX':"{_nbfc_exec 'nbfc complete-fans'}"
    '(--watch -w)'{-w+,--watch=}'[Show status periodically]':SECONDS:"_numbers -f"
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_config() {
  local -a args=(
    '(--apply --recommend --set -a -r -s --list -l)'{-l,--list}'[List all available configs (default)]'
    '(--apply --list --recommend -a -l -r --set -s)'{-s+,--set=}'[Set a config]':config:"_files -W @DATADIR@/nbfc/configs"
    '(--list --recommend --set -l -r -s --apply -a)'{-a+,--apply=}'[Set a config and enable fan control]':config:"_files -W @DATADIR@/nbfc/configs"
    '(--apply --list --set -a -l -s --recommend -r)'{-r,--recommend}'[List configs which may work for your device]'
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_set() {
  local -a args=(
    '(--speed -s --auto -a)'{-a,--auto}"[Set fan speed to 'auto']"
    '(--auto -a --speed -s)'{-s+,--speed=}'[Set fan speed to PERCENT]':PERCENT:"_numbers -f"
    '(--fan -f)'{-f+,--fan=}'[Fan index (zero based)]':'FAN INDEX':"{_nbfc_exec 'nbfc complete-fans'}"
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_sensors() {
  local opts=-h,--help,--version
  local HAVING_OPTIONS=() OPTION_VALUES=() POSITIONALS=() INCOMPLETE_OPTION=''
  _nbfc_zsh_query init "$opts" "${words[@]}"

  case "$(_nbfc_zsh_query get_positional 2)" in
    (list) _nbfc_sensors_list; return $?;;
    (show) _nbfc_sensors_show; return $?;;
    (set) _nbfc_sensors_set; return $?;;
  esac

  local -a args=(
    1:command1:_nbfc__command
    2:command2:_nbfc_sensors_command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_sensors_list() {
  local -a args=(
    1:command1:_nbfc__command
    2:command2:_nbfc_sensors_command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_sensors_show() {
  local -a args=(
    1:command1:_nbfc__command
    2:command2:_nbfc_sensors_command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_sensors_set() {
  local -a args=(
    '(--fan -f)'{-f+,--fan=}'[Fan index (zero based)]':'FAN INDEX':"{_nbfc_exec 'nbfc complete-fans'}"
    '(--algorithm -a)'{-a+,--algorithm=}'[Set the algorithm type]':ALGORITHM:'(Average Min Max)'
    '*'{-s+,--sensor=}'[Set sensor]':SENSOR:"{_nbfc_exec 'nbfc complete-sensors'}"
    '(--force)'--force'[Force applying sensors]'
    1:command1:_nbfc__command
    2:command2:_nbfc_sensors_command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_update() {
  local -a args=(
    '(--parallel -p)'{-p+,--parallel=}'[Set number of parallel downloads]':NUM:_numbers
    '(--quiet -q)'{-q,--quiet}'[Enable quiet mode]'
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_wait_for_hwmon() {
  local -a args=(
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_get_model_name() {
  local -a args=(
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_warranty() {
  local -a args=(
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_donate() {
  local -a args=(
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc_help() {
  local -a args=(
    1:command1:_nbfc__command
  )
  _arguments -S -s -w "${args[@]}"
}

_nbfc "$@"

# vim: ft=zsh ts=2 sts=2 sw=2 et
